load "msh3"
load "medit"
load "tetgen"

/*
int nn = 10;
//func f1 = cos(t)*cos(t);
//func f2 = cos(t)*sin(t);
//func f3 = sin(x);
// 2D mesh

border s0(t=0, 2*pi){x=0.5*cos(t); y=0.5*sin(t);}
border cc(t=0, 2*pi){x=cos(t); y=sin(t);}
mesh Th2 = buildmesh(cc(100) + s0(-50));
//mesh Th = buildmesh(a0(2*n) + s0(-20));



//{x =  cos(t)*cos(t);y = cos(t)*sin(t);z =  sin(t);}
//mesh Th2 = buildmesh(s0(20));
// 3D mesh
//int[int] rup = [0, 2], rlow = [0, 1];

//func zmin = 2-sqrt(4-(x*x+y*y));
//func zmax = 2-sqrt(3.);

mesh3 Th = buildlayers(Th2, nn);
    //zbound=[zmin,zmax],
    //labelup=rup,
    //labeldown=rlow);
// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Macro
macro Grad(u) [dx(u), dy(u), dz(u)] //

// Define the weak form and solve


// Plot
plot(Th);
*/






// Parameter
real hh = 0.1;

// Mesh 2D
mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // ]-pi/2, pi/2[X]0, 2pi[
// A parametrization of a sphere
func f1 = cos(x)*cos(y);
func f2 = cos(x)*sin(y);
func f3 = sin(x);
// Partial derivative of the parametrization DF
func f1x = sin(x)*cos(y);
func f1y = -cos(x)*sin(y);
func f2x = -sin(x)*sin(y);
func f2y = cos(x)*cos(y);
func f3x = cos(x);
func f3y = 0;
//M = DF^t DF
func m11 = f1x^2 + f2x^2 + f3x^2;
func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
func m22 = f1y^2 + f2y^2 + f3y^2;

// Periodic condition
func perio = [[4, y], [2, y], [1, x], [3, x]];

// Mesh adaptation
real vv = 1/square(hh);
//Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, inquire=1, periodic=perio);
//Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
//Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
//Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);

// Sphere
meshS Th3 = movemesh23(Th, transfo=[f1, f2, f3]);
plot(Th3);