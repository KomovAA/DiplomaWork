verbosity=1;
load "msh3"
load "tetgen"
load "mshmet"
load "medit"
include "MeshSurface.idp"
include "ffmatlib.idp"

real c0 = 299792458;        // speed of light in vacuum
real mue0 = 4.*pi*1e-7;     // Permeability of free space
real eps0 = 1./c0^2/mue0;   // Permittivity of free space
real Z0 = sqrt(mue0/eps0);  // Impedance of free space

real    lambda0 = 10e-6;        // vacuum wavelength (in m)
complex ns    = 10.-0*1i*70.;   // sphere refractive index (complex)
real radiusOfInnerSpher = 1.5 * lambda0;

real lambda = 1.;        // vacuum wavelength (in 10*1e-6 m)
     radiusOfInnerSpher = 0.5 * lambda;

real k0 = 2.* pi / lambda;
//complex k = k0 * ns;
real w = c0 * 2.* pi / lambda0;

 
// 
meshS ThSphOut;
real volumetet;

real hs = 0.2;
ThSphOut = Sphere(4.,hs,8,1);
meshS Thsph; 
Thsph = Sphere(radiusOfInnerSpher,hs,7,1);


////////////////////////////////
meshS ThS = ThSphOut + Thsph; // "gluing" surface meshs to tolat boundary meshes
//medit("Bounday mesh",ThS,wait=1);

// build a mesh of a axis parallel box with TetGen
real[int] domaine = [0,0,0,1,volumetet,0,0,0.7,2,volumetet];
mesh3 Th = tetg(ThS,switch="pqaAAYYQ",nbofregions=2,regionlist=domaine);    
// Tetrahelize the interior of the cube with tetgen
medit("tetg",Th,wait=1);
savemesh(Th,"Th-hex-sph.mesh");

fespace Ph(Th,P03d);
fespace Vh(Th,P13d);
Ph reg=region;

cout << "  centre = " << reg(0,0,0) << endl;
cout << " exterieur = " << reg(0,0,0.7) << endl;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

/*
Vh uh,vh;
Vh f = 200.*(sqrt(x^2.+y^2. + z^2.) <= 0.3);
real gn = 1.;
real cf= 1;
problem Poisson(uh,vh)=
    int3d(Th,1)( Grad(uh)'*Grad(vh)*0.0100) 
  + int3d(Th,2)( Grad(uh)'*Grad(vh)*1.) 
  + int3d(Th) (vh*f)
  + on(8,uh=0)
//  + on(7,uh=4)
 /* + int2d(Th,2,-2)(vh*gn)
  + int2d(Th,3,-3)(cf*vh*uh)*/
 //; 
  
//plot(f,wait=1,fill=1);
//  Poisson;













real t = 0.;

Vh<complex> Hz, hz;
Vh<complex> Ey1 = exp(- 1i* k0 * x);
Vh <complex> Ez,ez,Ey,ey,Ex,ex;
Vh <complex> N0= 1. + (2.-1.)*(sqrt(x^2.+y^2. + z^2.) < radiusOfInnerSpher);

Vh <complex> k = k0 * N0;
complex k2 = k0 * 2;


problem GelmhotzEquationForH3D([Ey],[ey])=
  - int3d(Th,1)( Grad(Ey)'* Grad(ey))
  + int3d(Th,1) (k0^2 * Ey* ey)
  - int3d(Th,2)( Grad(Ey)'* Grad(ey))
  + int3d(Th,2) (k2^2 * Ey* ey)
  + int2d(Th,7)
	(
	   N.x*dx(Ey1)*ey
	)
  + int2d(Th,8)
	(
	   -1i*k0* Ey*ey
	)
  ; 
  
  GelmhotzEquationForH3D;

Vh realHz, realEx, realEy,realEy1;
Vh<complex> HzInTime = 0.;
Vh<complex> Ey1InTime = 0.;
Vh<complex> E0=1.;
Ey = Ey + 0*(E0 * exp (- 1i * k0 * x )) * (sqrt(x^2.+y^2. + z^2.) >= radiusOfInnerSpher);

cout << "k0 = " << k0 << endl;
//cout << "k = " << k << endl;

///// save for the matlab
savemesh(Th,"diffractionSInS3d.mesh");
ffSaveVh(Th,Vh,"diffractionSInS3d_vh.txt");
ffSaveData(Ey,"diffractionSInS3d_Ey.txt");
/////////////////////////

realEy = real(Ey);
plot(realEy,wait=1,fill=1);
  
  
/* 
real errm=1e-2;// level of error 
for(int ii=0; ii<5; ii++)
{
  Poisson;
  cout <<" u min, max = " <<  uh[].min << " "<< uh[].max << endl;
  Vh h ;
  h[]=mshmet(Th,uh,normalization=1,aniso=0,nbregul=1,hmin=1e-3,hmax=0.3,err=errm);//loptions=MSHloptions,doptions=MSHdoptions);
  cout <<" h min, max = " <<  h[].min << " "<< h[].max << " " << h[].n << " " << Th.nv << endl;
  // FFCS: add 3D view parameters
  plot(uh,wait=1,fill=0,boundary=0,CutPlane=0,ShowMeshes=1,LabelColors=0);
  errm*= 0.8;// change the level of error
  cout << " Th" << Th.nv < " " << Th.nt << endl;
  Th=tetgreconstruction(Th,switch="raAQ",sizeofvolume=h*h*h/6.);
//  medit("U-adap-iso-"+ii,Th,uh,wait=1);
}*/
  
  /*
  
// FFCS: with 3D view parameters
real[int] CameraPositionValue = [3.50634,-2.51489,2.60313];
real[int] CameraFocalPointValue = [0.0604689,-0.304636,-0.256484];
real[int] CameraViewUpValue = [0.7198,0.502367,-0.479078];
real[int] CutPlaneOriginValue = [-0.5,-0.55,0.0335184];
real[int] CutPlaneNormalValue = [0,0,1];
plot(uh,wait=1, nbiso=6,
	BorderAsMesh = 1,
	CameraPosition=CameraPositionValue,
	CameraFocalPoint=CameraFocalPointValue,
	CameraViewUp=CameraViewUpValue,
	CutPlaneOrigin=CutPlaneOriginValue,
	CutPlaneNormal = CutPlaneNormalValue);
//medit("   uh ",Th, uh,wait=1); 

///// save for the matlab
savemesh(Th,"diffractionSInS3d.mesh");
ffSaveVh(Th,Vh,"diffractionSInS3d_vh.txt");
ffSaveData(uh,"diffractionSInS3d_Ey.txt");
/////////////////////////
*/

